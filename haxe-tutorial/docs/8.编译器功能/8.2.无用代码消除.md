# 8.2.无用代码消除

无用代码消除或者DCE是一个编译器功能，它从输出中删除未使用的代码。在类型检查之后，编译器执行DCE入口点（通常是main方法）并递归的确定哪些字段和类型被使用了。使用的字段相应进行标记，未标记的字段然后从它们的类中移除。

DCE有三个模式，当调用命令行的时候设置：

`-dce std` ：只有Haxe标准库中的类被DCE影响。这是所有目标语言默认的设置。
`-dce no` ：不执行任何DCE。
`-dce full` ：所有的类都被DCE影响。

DCE算法和类型化算法运作良好，但是当 dynamic（第2.7节）或者 反射（第10.7节）被使用时可能失败。这可能需要通过如下元数据归类明确标记的字段或者类被使用：

- @:keep ： 如果使用在类上，类和所有字段一起都不会受到DCE的影响。如果用在字段上，那个字段不受DCE影响。
- @:keepSub ：如果用在一个类上，它就像 @:keep 用在一个注释的类上，以及所有子类。
- @:keepInit ：通常，一个被DCE移除所有字段的类（或者一个开始为空的）会从输出中移除。通过使用这个元数据，空类被保留。

如果一个类需要被从命令行标记 @:keep 而不是编辑它的源代码，有一个编译器宏可用： --macro keep("type dot path") 。查看 haxe.macro.Compiler.keep API 了解这个宏的详情。它会标记包、模块或者子类型被DCE保留，包含它们进行编译。
编译器根据活动模式自动使用值“std”，“no”或者“full”定义dce。这可以被用在条件编译（第6.1节）。

> 花絮：DCE重写
> DCE最初在Haxe 2.07中实现。这个实现考虑过一个函数，被用在显式的类型化时。但是问题是一些功能，多数重要的接口，会使所有的类字段被类型化以验证类型安全。这有效的完全颠覆了DCE，激励了Haxe2.10中的重写。

> 花絮：[DCE和try.haxe.org](http://xn--dcetry-k76j.haxe.org/)
> 对于JavaScript目标语言的DCE，在网站 [http://try.haxe.org](http://try.haxe.org/) 被发布时可以看到巨大的改进。生成的JavaScript代码最初的感受是混合，使得更细致的选择排除哪些代码。