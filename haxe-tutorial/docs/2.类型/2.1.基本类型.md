# 2.1.基本类型

基本类型包括 `Bool`，`Float` 和 `Int`。很容易在语法中通过值认出它们：

-  `Bool` 类型的值 `true` 和 `false`
- `Int` 类型的值 `1`, `0`, `-1` 和 `0xFF0000`
- `Float` 类型的值 `1.0`, `0.0`, `-1.0`, `1e10`

在 Haxe 中，基本类型并不是 [类（第2.3节）](/2.类型/2.3.类实例)。它们被实现为 [抽象类型（第2.8节）](/2.类型/2.8.抽象类型)，并且与编译器内部的操作符处理进行绑定，将在后面的小节中展开讲述。



# 2.1.1.数值类型

> **定义**： Float
> 表示一个双精度 IEEE 64 位浮点数

> **定义**： Int
> 表示一个整数

尽管可以在任何期待 `Float` 类型的位置放置一个 `Int` 类型（也就是说， `Int` 可以被赋值到 `Float` 类型上，或者说 `Int` 类型可以**统一**为 `Float` 类型），但是反之则不行：把一个 `Float` 类型的值赋值给 `Int` 类型可能会导致精度丢失，Haxe 不允许此类隐式转换。



补充：

你可以使用 Haxe 标准库的函数把  `Float`  类型转换为 `Int` 类型，比如：

```haxe
var intDivision = Std.int(6.2/4.7)
```



# 2.1.2.溢出

出于性能原因，Haxe 编译器不实施任何溢出行为。溢出检查的任务落到目标平台。下面是一些平台特定的溢出行为的提示：

- C++，Java，C#，Neko，Flash：32位带符号整数有通常的溢出惯例。
- PHP，JS，Flash 8：没有原生的 Int 类型，如果数值到达最大浮点数限制（2^52）则会发生精度的损失。

另外，`haxe.Int32` 和 `haxe.Int64` 类可以用来确保正确的溢出行为，与平台无关，而额外的计算成本取决于目标平台。



# 2.1.3.Bool类型

> **定义** Bool：
> Bool 类型表示一个非 `true` 即 `false` 的值。

Bool 类型的值经常出现在条件中，例如 `if(5.16)` 和 `while(5.14)` 。下面的运算符接受并返回 Bool 类型的值：

- && （和）
- || （或）
- ! （非）

Haxe 保证混合的布尔表达式在运行时从左到右被评估，并且只进行需要的评估。
 例如，表达式 `A && B` 会首先执行 `A` ，然后再执行 `B`，并且只有在 `A` 的结果为 `true` 的时候才继续执行 `B`。同样，表达式 `A || B` 在 `A` 的执行结果为 `true` 的时候不会执行 `B`，因为这时 `B` 的值是无关紧要的。在如下情况这很重要：

```haxe
if (object != null && object.field == 1) { }
```

如果 `object` 为 `null` 的时候访问 `object.field` 会导致一个运行时错误，但是对 `object != null` 的检查则会防止它。



# 2.1.4.Void类型

> **定义** Void：
> `Void` 表示一个类型的缺失。它用来表达一些东西（通常是一个函数）没有值。

`Void` 是类型系统中的一个特殊情况，因为它实际上不是一个类型。它用来表达一个类型的缺省，多数时候用于函数参数和返回类型。我们在开始的 “Hello World” 例子中已经见到过 `Void`。

```haxe
class Main {
    static public function main():Void {
        trace("Hello World");
    }
}
```

在 [函数类型（第2.6节）](/2.类型/2.6.函数类型) 中将会探索函数类型的详细信息，这里快速预览一下：例子中函数 `main` 的类型为 `Void->Void` ，表示没有参数和返回值。Haxe 不允许 `Void` 类型的字段和变量，如果尝试这样声明，它会发出抱怨：

```haxe
// Void类型的参数和变量是不被允许的 
var x:Void;
```

**注：【环境：Haxe 3.3.0-rc.1】在实际编写测试代码的时候，尝试在类的 `main` 函数内定义 `var x:Void;` 并未报错，而作为类字段进行定义则不能编译，提示 “Fields of type Void are not allowed”。**



# 2.1.5.为空性

> **定义** 可空的：
> 在 Haxe 中如果 `null` 对于一个类型是有效的值，则认为类型是可空的。

在编程语言中有一个单一、清楚的为空性定义非常常见。然而，Haxe 由于其平台无关的性质，需要在这个问题中找到一个妥协：在某些目标语言中允许且事实上默认给任意类型赋 `null` 值，而另外一些语言则甚至不允许 `null` 值作为某些类型的值。因此要明确区分出两种类型的语言：

> **定义** 静态目标
> 静态目标平台的类型系统不允许 `null` 值作为基本类型的值。比如 Flash，C++，Java 和 C# 目标平台。

> **定义** 动态目标：
> 动态目标平台的类型使用更为宽松，并允许基本类型使用 `null` 值。比如 JavaScript，PHP，Neko 和 Flash 6-8 目标平台。

如果编译至动态目标下使用 `null` 时不需要担心；然而，如果要编译至静态目标平台可能需要一些考虑。首先，基本类型的值会被初始化为它们的默认值。

> **定义**：默认值
> 静态目标语言中，基本类型的默认值如下：
>
> - `Int` ：`0`
> - `Float`：Flash 平台下初始值为 `NaN` ，其他平台下为 `0.0`
> - `Bool`：`false`

因此，静态目标平台下 Haxe 编译器不允许给基本数据类型赋 `null` 值，如果要这么做，基本数据类型需要包装为 `Null<T>` 类型。

```haxe
// 静态目标平台报错
var a:Int = null; 
// 允许的
var b:Null<Int> = null; 
```

同样，基本类型不能跟 `null` 进行比较，除非它被包装过：

```haxe
var a : Int = 0;

// 静态目标平台报错
if( a == null ) { ... }

var b : Null<Int> = 0; 
if( b != null ) { ... } // 允许的
```

这一限制会延伸至所有 [一致性检查（第3.5节）](/3.类型系统/3.5.一致性检查) 被执行的情况。

> **定义** `Null<T>`：
> 在静态目标平台下，可以使用 `Null<Int>`、`Null<Float>`、和 `Null<Bool>` 类型来允许 `null` 作为一个有效值。在动态目标平台下，这样做没有影响。`Null<T>` 也可以被用于其它类型用以表示 `null` 是一个允许的值。

如果一个 `null` 值被 “隐藏” 在 `Null<T>` 或者 `Dynamic` 中 ，并被赋值给一个基本类型，会对其赋默认值：

```haxe
 var n : Null<Int> = null;
 var a : Int = n;
 trace(n); // 输出 null
 trace(a); // 在静态目标平台输出 0
```

# 2.2.6.可选参数和为空性

可选参数在考虑为空性时需要注意，需要在不可空的**原生**可选参数和可能为空的 Haxe特定（Haxe-Specific) 可选参数之间进行区分。这种区分是通过使用问号可选参数来实现的。

```haxe
// x是一个原生 Int（不能为空） 
function foo(x : Int = 0) {} 

// y是一个 Null<T>类型 (可空) 
function bar( ?y : Int) {} 

// z同样是 Null<T> 
function opt( ?z : Int = -1) {}
```

> 花絮：Argument 和 Parameter
> 在一些其它的编程语言中，argument 和 parameter 可以交替使用。在 Haxe 中，argument 在针对方法的时候使用，而 parameter 是指 [类型参数（第3.2节）](/3.类型系统/3.2类型参数)。